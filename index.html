<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Visor PDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }
    
#pdfContainer {
  width: calc(100% - 6px); /* En lugar de 96%, calculamos el espacio total menos los márgenes */
  max-width: 400px;
  margin: 3px auto; /* Margen de 3px en todos los lados */
  padding: 3px;
  box-sizing: border-box; /* Asegura que padding no altere el tamaño del contenedor */
}
    /* El wrapper del canvas permite scroll si la página es grande, giros o zoom */
    #canvasWrapper {
      border: 1px solid #ccc;
      width: 100%;
      height: 555px;
      overflow: auto;
      position: relative;
      background: #eee;
    }
    canvas {
      display: block;
      /* Sin transición para evitar el efecto de parpadeo en zoom in/out */
    }
    /* Controles debajo del canvas */
    #controls {
      margin-top: 10px;
      width: 100%;
      max-width: 400px;
    }
    #buttonContainer {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    /* Centramos la barra deslizante */
    #sliderContainer {
      margin-bottom: 10px;
      text-align: center;
    }
    #sliderContainer input[type="range"] {
      width: 90%;
      vertical-align: middle;
    }
    /* Botones para rotar */
    #actionButtons {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    /* El botón de carga se coloca al final y centrado */
    #fileContainer {
      display: flex;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="pdfContainer">
    <div id="canvasWrapper">
      <canvas id="pdfCanvas"></canvas>
    </div>
    <div id="controls">
      <div id="buttonContainer">
        <button id="prevPage">← Anterior</button>
        <span id="pageCounter">01 / 40</span>
        <button id="nextPage">Siguiente →</button>
      </div>
      <div id="sliderContainer">
        <input type="range" id="pageSlider" min="1" step="1" value="1">
      </div>
      <div id="actionButtons">
        <button id="rotateLeft">↩️</button>
        <button id="rotateRight">↪️</button>
      </div>
      <div id="fileContainer">
        <input type="file" id="fileInput" accept="application/pdf">
      </div>
    </div>
  </div>
  
  <script>
    let pdfDoc = null,
        pageNum = 1,
        rendering = false,
        pdfLoaded = false,
        currentRotation = 0,
        sliderTimeout = null,
        zoomFactor = 1.0;

    const canvasWrapper = document.getElementById('canvasWrapper');
    const canvas = document.getElementById('pdfCanvas');

    // Al cargar un PDF, se reinician giro y zoom
    document.getElementById('fileInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const pdfData = new Uint8Array(this.result);
          pdfjsLib.getDocument({ data: pdfData }).promise.then(pdf => {
            pdfDoc = pdf;
            pageNum = 1;
            pdfLoaded = true;
            // Reset de giro y zoom al cargar uno nuevo:
            currentRotation = 0;
            zoomFactor = 1.0;
            document.getElementById("pageSlider").max = pdf.numPages;
            updateCounter();
            renderPage(pageNum);
          }).catch(error => console.error("Error al cargar el PDF:", error));
        };
        fileReader.readAsArrayBuffer(file);
      }
    });

    function renderPage(num) {
      if (!pdfLoaded || rendering) return;
      rendering = true;
      pdfDoc.getPage(num).then(page => {
        const context = canvas.getContext('2d');
        // IMPORTANTE: Se calcula la escala en función del pdf en modo vertical
        const baseViewport = page.getViewport({ scale: 1, rotation: 0 });
        // Siempre ajustamos al ancho disponible del canvasWrapper
        let scale = (canvasWrapper.clientWidth / baseViewport.width) * zoomFactor;
        // Se renderiza la página con la rotación actual, pero usando la escala calculada con rotation 0.
        const viewport = page.getViewport({ scale: scale, rotation: currentRotation });
        const outputScale = window.devicePixelRatio || 1;
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = viewport.width + "px";
        canvas.style.height = viewport.height + "px";

        // Alineamos a la izquierda (marginLeft = 0) y centramos verticalmente
        let marginLeft = 0;
        let marginTop = 0;
        if (viewport.height < canvasWrapper.clientHeight) {
          marginTop = (canvasWrapper.clientHeight - viewport.height) / 2;
        }
        canvas.style.marginLeft = marginLeft + "px";
        canvas.style.marginTop = marginTop + "px";

        context.clearRect(0, 0, canvas.width, canvas.height);
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
          transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
        };
        page.render(renderContext).promise.then(() => {
          rendering = false;
        });
        pageNum = num;
        updateCounter();
      });
    }

    function updateCounter() {
      const totalPages = pdfDoc.numPages;
      const formattedPageNum = pageNum < 10 ? '0' + pageNum : pageNum;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + totalPages;
      document.getElementById("pageSlider").value = pageNum;
    }

    document.getElementById('prevPage').addEventListener('click', () => {
      if (pageNum > 1) {
        renderPage(pageNum - 1);
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      if (pageNum < pdfDoc.numPages) {
        renderPage(pageNum + 1);
      }
    });

    document.getElementById('pageSlider').addEventListener('input', (event) => {
      if (!pdfLoaded) return;
      const newPage = parseInt(event.target.value, 10);
      // Actualiza el contador inmediatamente
      const formattedPageNum = newPage < 10 ? '0' + newPage : newPage;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + pdfDoc.numPages;
      if (sliderTimeout) clearTimeout(sliderTimeout);
      sliderTimeout = setTimeout(() => {
        if (newPage !== pageNum) {
          renderPage(newPage);
        }
      }, 150);
    });

    document.getElementById('rotateLeft').addEventListener('click', () => {
      currentRotation = (currentRotation - 90 + 360) % 360;
      renderPage(pageNum);
    });

    document.getElementById('rotateRight').addEventListener('click', () => {
      currentRotation = (currentRotation + 90) % 360;
      renderPage(pageNum);
    });

    // Zoom mediante gesto pinch (no permite bajar de 1)
    let pinchZoom = { initialDistance: 0, initialZoomFactor: 1 };
    canvasWrapper.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        pinchZoom.initialDistance = getDistance(e.touches[0], e.touches[1]);
        pinchZoom.initialZoomFactor = zoomFactor;
        e.preventDefault();
      }
    }, { passive: false });

    canvasWrapper.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
        let currentDistance = getDistance(e.touches[0], e.touches[1]);
        zoomFactor = pinchZoom.initialZoomFactor * (currentDistance / pinchZoom.initialDistance);
        if (zoomFactor < 1) zoomFactor = 1;
        renderPage(pageNum);
        e.preventDefault();
      }
    }, { passive: false });

    function getDistance(touch1, touch2) {
      const dx = touch1.pageX - touch2.pageX;
      const dy = touch1.pageY - touch2.pageY;
      return Math.sqrt(dx * dx + dy * dy);
    }
  </script>
</body>
</html>

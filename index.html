<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes">
  <title>Visor PDF - AlphaPDF</title>
  <script src="https://unpkg.com/pdfjs-dist@5.2.133/build/pdf.min.js"></script>
  <script>
    // Configurar el worker y el decodificador OpenJPEG para PDF.js 5.2.133
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@5.2.133/build/pdf.worker.min.js';
    pdfjsLib.GlobalWorkerOptions.wasmUrl = 'https://unpkg.com/pdfjs-dist@5.2.133/web/openjpeg.wasm';
  </script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: #b5b5b5;
    }
    #pdfContainer {
      width: calc(100% - 4px);
      max-width: 1020px;
      margin: 2px auto;
      padding: 6px;
      box-sizing: border-box;
    }
    @media (max-width: 768px) {
      #pdfContainer {
        width: calc(100% - 4px);
        max-width: 600px;
        margin: 2px auto;
        padding: 6px;
      }
    }
    #canvasWrapper {
      border: 1px solid #ccc;
      width: 100%;
      height: 555px;
      overflow: auto;
      position: relative;
      background: #eee;
    }
    canvas {
      display: block;
      transform: none;
      /* Asegurar visibilidad */
      position: relative;
      z-index: 1;
    }
    #controls {
      margin-top: 20px;
      width: 100%;
      max-width: 600px;
    }
    #buttonContainer {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
      margin-bottom: 30px;
    }
    #sliderContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #sliderContainer input[type="range"] {
      width: 64%;
      vertical-align: middle;
    }
    #actionButtons {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    #fileContainer {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div id="pdfContainer">
    <div id="canvasWrapper">
      <canvas id="pdfCanvas"></canvas>
    </div>
    <div id="controls">
      <div id="buttonContainer">
        <button id="prevPage">⬅️</button>
        <span id="pageCounter">## / ##</span>
        <button id="nextPage">➡️</button>
      </div>
      <div id="sliderContainer">
        <input type="range" id="pageSlider" min="1" step="1" value="1">
      </div>
      <div id="actionButtons">
        <button id="rotateLeft">↪️</button>
        <button id="rotateRight">↩️</button>
      </div>
      <div id="fileContainer">
        <input type="file" id="fileInput" accept="application/pdf">
      </div>
    </div>
  </div>
  
  <script>
    let pdfDoc = null,
        pageNum = 1,
        rendering = false,
        pdfLoaded = false,
        currentRotation = 0,
        sliderTimeout = null,
        zoomFactor = 1.0,
        pinchZoom = {
          initialDistance: 0,
          initialZoomFactor: 1,
          initialScrollLeft: 0,
          initialScrollTop: 0,
          pinchCenterX: 0,
          pinchCenterY: 0
        },
        lastTempZoom = null,
        isPinching = false;
    
    const canvasWrapper = document.getElementById('canvasWrapper');
    const canvas = document.getElementById('pdfCanvas');
    
    // Cargar un PDF por defecto para pruebas
    window.addEventListener('DOMContentLoaded', () => {
      const defaultPdfUrl = 'https://mozilla.github.io/pdf.js/web/compressed.tracemonkey-pldi-09.pdf';
      fetch(defaultPdfUrl)
        .then(response => response.arrayBuffer())
        .then(data => {
          pdfjsLib.getDocument({ 
            data: data,
            useSystemFonts: true,
            cMapUrl: 'https://unpkg.com/pdfjs-dist@5.2.133/cmaps/',
            cMapPacked: true
          }).promise.then(pdf => {
            pdfDoc = pdf;
            pageNum = 1;
            pdfLoaded = true;
            currentRotation = 0;
            zoomFactor = 1.0;
            document.getElementById("pageSlider").max = pdf.numPages;
            updateCounter();
            renderPage(pageNum);
          }).catch(error => {
            console.error("Error al cargar el PDF por defecto:", error);
            alert("No se pudo cargar el PDF por defecto.");
          });
        }).catch(error => {
          console.error("Error al descargar el PDF por defecto:", error);
        });
    });

    // Cargar el PDF mediante file input
    document.getElementById('fileInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file && file.type === 'application/pdf') {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const pdfData = new Uint8Array(this.result);
          pdfjsLib.getDocument({ 
            data: pdfData,
            useSystemFonts: true,
            cMapUrl: 'https://unpkg.com/pdfjs-dist@5.2.133/cmaps/',
            cMapPacked: true
          }).promise.then(pdf => {
            pdfDoc = pdf;
            pageNum = 1;
            pdfLoaded = true;
            currentRotation = 0;
            zoomFactor = 1.0;
            document.getElementById("pageSlider").max = pdf.numPages;
            updateCounter();
            renderPage(pageNum);
          }).catch(error => {
            console.error("Error al cargar el PDF:", error);
            alert("No se pudo cargar el PDF. Asegúrate de que el archivo es válido.");
          });
        };
        fileReader.onerror = () => {
          console.error("Error al leer el archivo.");
          alert("Error al leer el archivo PDF.");
        };
        fileReader.readAsArrayBuffer(file);
      } else {
        alert("Por favor, selecciona un archivo PDF válido.");
      }
    });
    
    // renderPage: Re-renderiza la página usando zoomFactor y currentRotation
    function renderPage(num, callback) {
      if (!pdfLoaded || rendering) return;
      rendering = true;
      pdfDoc.getPage(num).then(page => {
        const context = canvas.getContext('2d');
        const baseViewport = page.getViewport({ scale: 1, rotation: currentRotation });
        // Calcular escala para ajustar al ancho del contenedor
        const scale = (canvasWrapper.clientWidth / baseViewport.width) * zoomFactor;
        console.log(`Renderizando página ${num} con escala: ${scale}, zoom: ${zoomFactor}`);
        const viewport = page.getViewport({ scale: scale, rotation: currentRotation });
        const outputScale = window.devicePixelRatio || 1;
    
        // Configurar dimensiones del canvas
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = viewport.width + "px";
        canvas.style.height = viewport.height + "px";
        console.log(`Canvas dimensiones: width=${canvas.width}, height=${canvas.height}, style.width=${canvas.style.width}, style.height=${canvas.style.height}`);
    
        // Centrar el canvas
        let marginLeft = (canvasWrapper.clientWidth - viewport.width) / 2;
        let marginTop = (canvasWrapper.clientHeight - viewport.height) / 2;
        canvas.style.marginLeft = marginLeft > 0 ? marginLeft + "px" : "0px";
        canvas.style.marginTop = marginTop > 0 ? marginTop + "px" : "0px";
        console.log(`Márgenes: left=${canvas.style.marginLeft}, top=${canvas.style.marginTop}`);
    
        // Limpiar canvas antes de renderizar
        context.clearRect(0, 0, canvas.width, canvas.height);
        const renderContext = {
          canvasContext: context,
          viewport: viewport,
          transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
        };
    
        page.render(renderContext).promise.then(() => {
          console.log(`Página ${num} renderizada correctamente`);
          rendering = false;
          updateCounter();
          if (callback) callback();
        }).catch(error => {
          console.error("Error al renderizar la página:", error);
          rendering = false;
        });
    
        pageNum = num;
        updateCounter();
      }).catch(error => {
        console.error("Error al obtener la página:", error);
        rendering = false;
      });
    }
    
    // updateCounter: Actualiza el contador y el slider de página
    function updateCounter() {
      if (!pdfDoc) {
        document.getElementById("pageCounter").textContent = "## / ##";
        document.getElementById("pageSlider").value = 0;
        return;
      }
      const totalPages = pdfDoc.numPages;
      const formattedPageNum = pageNum < 10 ? '0' + pageNum : pageNum;
      const formattedTotalPages = totalPages < 10 ? '0' + totalPages : totalPages;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + formattedTotalPages;
      document.getElementById("pageSlider").value = pageNum;
    }
    
    // Botones de navegación y rotación
    document.getElementById('prevPage').addEventListener('click', () => {
      if (pageNum > 1) renderPage(pageNum - 1);
    });
    document.getElementById('nextPage').addEventListener('click', () => {
      if (pdfDoc && pageNum < pdfDoc.numPages) renderPage(pageNum + 1);
    });
    document.getElementById('pageSlider').addEventListener('input', (event) => {
      if (!pdfLoaded) return;
      const newPage = parseInt(event.target.value, 10);
      const formattedPageNum = newPage < 10 ? '0' + newPage : newPage;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + pdfDoc.numPages;
      if (sliderTimeout) clearTenTimeout(sliderTimeout);
      sliderTimeout = setTimeout(() => {
        if (newPage !== pageNum) renderPage(newPage);
      }, 150);
    });
    document.getElementById('rotateLeft').addEventListener('click', () => {
      currentRotation = (currentRotation - 90 + 360) % 360;
      renderPage(pageNum);
    });
    document.getElementById('rotateRight').addEventListener('click', () => {
      currentRotation = (currentRotation + 90) % 360;
      renderPage(pageNum);
    });
    
    // getDistance: Calcula la distancia entre dos toques
    function getDistance(touch1, touch2) {
      const dx = touch1.pageX - touch2.pageX;
      const dy = touch1.pageY - touch2.pageY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Zoom por pellizco
    canvasWrapper.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
         e.preventDefault();
         isPinching = true;
         pinchZoom.initialDistance = getDistance(e.touches[0], e.touches[1]);
         pinchZoom.initialZoomFactor = zoomFactor;
         pinchZoom.initialScrollLeft = canvasWrapper.scrollLeft;
         pinchZoom.initialScrollTop = canvasWrapper.scrollTop;
         const rect = canvas.getBoundingClientRect();
         pinchZoom.pinchCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
         pinchZoom.pinchCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
         canvas.style.transformOrigin =
           ((pinchZoom.pinchCenterX / canvas.clientWidth) * 100) + "% " +
           ((pinchZoom.pinchCenterY / canvas.clientHeight) * 100) + "%";
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
         e.preventDefault();
         const currentDistance = getDistance(e.touches[0], e.touches[1]);
         let tempZoom = pinchZoom.initialZoomFactor * (currentDistance / pinchZoom.initialDistance);
         tempZoom = Math.max(1, Math.min(tempZoom, 5));
         lastTempZoom = tempZoom;
         canvas.style.transform = "scale(" + (tempZoom / pinchZoom.initialZoomFactor) + ")";
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchend', function(e) {
      if (isPinching && e.touches.length < 2) {
         canvas.style.transform = "";
         if (lastTempZoom) {
            zoomFactor = lastTempZoom;
         }
         renderPage(pageNum, function() {
           const zoomRatio = zoomFactor / pinchZoom.initialZoomFactor;
           const newScrollLeft = pinchZoom.initialScrollLeft + pinchZoom.pinchCenterX * (zoomRatio - 1);
           const newScrollTop = pinchZoom.initialScrollTop + pinchZoom.pinchCenterY * (zoomRatio - 1);
           canvasWrapper.scrollLeft = newScrollLeft;
           canvasWrapper.scrollTop = newScrollTop;
         });
         isPinching = false;
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchcancel', function(e) {
      if (isPinching && e.touches.length < 2) {
         canvas.style.transform = "";
         isPinching = false;
      }
    }, { passive: false });
  </script>
</body>
</html>

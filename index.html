<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="device-width, initial-scale=1, user-scalable=yes">
  <title>Visor PDF - AlphaPDF</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
  <script>
    // Configurar el worker para PDF.js 3.10.111
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js';
  </script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      background: #b5b5b5;
    }
    #pdfContainer {
      width: calc(100% - 4px);
      max-width: 1020px;
      margin: 2px auto;
      padding: 6px;
      box-sizing: border-box;
    }
    @media (max-width: 768px) {
      #pdfContainer {
        width: calc(100% - 4px);
        max-width: 600px;
        margin: 2px auto;
        padding: 6px;
      }
    }
    #canvasWrapper {
      border: 1px solid #ccc;
      width: 100%;
      height: 555px;
      overflow: auto;
      position: relative;
      background: #eee;
      min-width: 100px;
      min-height: 100px;
    }
    canvas {
      display: block;
      transform: none;
    }
    #controls {
      margin-top: 20px;
      width: 100%;
      max-width: 600px;
    }
    #buttonContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
      margin-bottom: 30px;
    }
    #sliderContainer {
      margin-bottom: 20px;
      text-align: center;
    }
    #sliderContainer input[type="range"] {
      width: 64%;
      vertical-align: middle;
    }
    #actionButtons {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
    }
    #extraControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-bottom: 30px;
    }
    #fileContainer {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    #toggleFullscreen.active {
      color: #007bff; /* Azul cuando est√° en fullscreen */
    }
    #toggleFullscreen {
      color: #808080; /* Gris cuando no est√° en fullscreen */
    }
  </style>
</head>
<body>
  <div id="pdfContainer">
    <div id="canvasWrapper">
      <canvas id="pdfCanvas"></canvas>
    </div>
    <div id="controls">
      <div id="buttonContainer">
        <button id="prevPage">‚¨ÖÔ∏è</button>
        <span id="pageCounter">## / ##</span>
        <button id="nextPage">‚û°Ô∏è</button>
      </div>
      <div id="sliderContainer">
        <input type="range" id="pageSlider" min="1" step="1" value="1">
      </div>
      <div id="actionButtons">
        <button id="zoomOut">‚ûñ</button>
        <button id="rotateLeft">‚Ü™Ô∏è</button>
        <button id="resetZoom">üîÑ</button>
        <button id="rotateRight">‚Ü©Ô∏è</button>
        <button id="zoomIn">‚ûï</button>
      </div>
      <div id="extraControls">
        <button id="toggleFullscreen">‚õ∂</button>
        <span id="canvasSize">[Resoluci√≥n: - x -]</span>
        <span id="zoomPercentage">[Zoom: -%]</span>
      </div>
      <div id="fileContainer">
        <input type="file" id="fileInput" accept="application/pdf">
      </div>
    </div>
  </div>
  
  <script>
    let pdfDoc = null,
        pageNum = 1,
        rendering = false,
        pdfLoaded = false,
        currentRotation = 0,
        sliderTimeout = null,
        zoomFactor = 1.0,
        pinchZoom = {
          initialDistance: 0,
          initialZoomFactor: 1,
          initialScrollLeft: 0,
          initialScrollTop: 0,
          pinchCenterX: 0,
          pinchCenterY: 0
        },
        lastTempZoom = null,
        isPinching = false,
        pageImages = {}, // Almacena im√°genes de p√°ginas
        currentImage = null; // Imagen actual mostrada
    
    const canvasWrapper = document.getElementById('canvasWrapper');
    const canvas = document.getElementById('pdfCanvas');
    
    // Funci√≥n para entrar/salir de pantalla completa
    function toggleFullscreen() {
      if (!document.fullscreenElement && !document.webkitFullscreenElement) {
        const requestFullscreen = document.documentElement.requestFullscreen || document.documentElement.webkitRequestFullscreen;
        if (requestFullscreen) {
          requestFullscreen.call(document.documentElement).catch(err => {
            alert('No se pudo activar pantalla completa: ' + err.message);
          });
        }
      } else {
        const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen;
        if (exitFullscreen) {
          exitFullscreen.call(document).catch(err => {
            alert('No se pudo salir de pantalla completa: ' + err.message);
          });
        }
      }
    }

    // Actualizar el estilo del bot√≥n seg√∫n el estado
    document.addEventListener('fullscreenchange', updateFullscreenButton);
    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);

    function updateFullscreenButton() {
      const toggleButton = document.getElementById('toggleFullscreen');
      toggleButton.className = document.fullscreenElement || document.webkitFullscreenElement ? 'active' : '';
    }
    
    // Generar imagen de alta calidad para una p√°gina
    async function generatePageImage(pageNum) {
      if (pageImages[pageNum]) return pageImages[pageNum]; // Usar imagen si ya existe
      const page = await pdfDoc.getPage(pageNum);
      const baseViewport = page.getViewport({ scale: 1, rotation: 0 });
      const imageScale = 2.5; // Resoluci√≥n alta optimizada (2.5x pantalla)
      const viewport = page.getViewport({ scale: imageScale, rotation: currentRotation });
      const tempCanvas = document.createElement('canvas');
      const context = tempCanvas.getContext('2d');
      tempCanvas.width = Math.floor(viewport.width);
      tempCanvas.height = Math.floor(viewport.height);
      await page.render({
        canvasContext: context,
        viewport: viewport,
        renderTextLayer: false,
        renderAnnotations: false
      }).promise;
      const image = tempCanvas.toDataURL('image/jpeg', 0.85); // JPEG optimizado
      pageImages[pageNum] = image;
      return image;
    }
    
    // Cargar el PDF mediante file input
    document.getElementById('fileInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file && file.type === 'application/pdf') {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const pdfData = new Uint8Array(this.result);
          pdfjsLib.getDocument({ 
            data: pdfData,
            enableScripting: false,
            renderInteractiveForms: false,
            disableAutoFetch: true
          }).promise.then(pdf => {
            pdfDoc = pdf;
            pageNum = 1;
            pdfLoaded = true;
            currentRotation = 0;
            zoomFactor = 1.0;
            pageImages = {}; // Limpiar im√°genes al cargar nuevo PDF
            document.getElementById("pageSlider").max = pdf.numPages;
            updateCounter();
            renderPage(pageNum);
          }).catch(error => {
            alert("Error al cargar el PDF: " + error.message);
          });
        };
        fileReader.onerror = () => {
          alert("Error al leer el archivo PDF.");
        };
        fileReader.readAsArrayBuffer(file);
      } else {
        alert("Por favor, selecciona un archivo PDF v√°lido.");
      }
    });
    
    // renderPage: Renderiza usando imagen
    async function renderPage(num, callback) {
      if (!pdfLoaded || rendering) return;
      rendering = true;
      try {
        const image = await generatePageImage(num); // Obtener imagen
        currentImage = new Image();
        currentImage.src = image;
        currentImage.onload = () => {
          const context = canvas.getContext('2d');
          const baseViewport = { width: currentImage.width / 2.5, height: currentImage.height / 2.5 }; // Escala base
          let scale;
          const isHorizontal = baseViewport.width > baseViewport.height;
          if (!isHorizontal) {
            const verticalScale = (canvasWrapper.clientWidth / baseViewport.width) * zoomFactor;
            scale = (currentRotation % 180 === 0)
                    ? verticalScale
                    : verticalScale * (baseViewport.height / baseViewport.width);
          } else {
            scale = (canvasWrapper.clientWidth / baseViewport.width) * zoomFactor;
          }
          const canvasWidth = baseViewport.width * scale;
          const canvasHeight = baseViewport.height * scale;
          const outputScale = window.devicePixelRatio || 1;
    
          canvas.width = Math.floor(canvasWidth * outputScale);
          canvas.height = Math.floor(canvasHeight * outputScale);
          canvas.style.width = canvasWidth + "px";
          canvas.style.height = canvasHeight + "px";
    
          // Actualizar resoluci√≥n
          document.getElementById('canvasSize').textContent = `[Resoluci√≥n: ${canvas.width/outputScale} x ${canvas.height/outputScale}]`;
          
          // Actualizar porcentaje de zoom
          const baseScale = isHorizontal ? (canvasWrapper.clientWidth / baseViewport.width) : (canvasWrapper.clientWidth / baseViewport.width);
          const zoomPercentage = Math.round((scale / baseScale) * 100);
          document.getElementById('zoomPercentage').textContent = `[Zoom: ${zoomPercentage}%]`;
    
          // Centrar el canvas
          let marginLeft = (canvasWrapper.clientWidth > canvasWidth) ? (canvasWrapper.clientWidth - canvasWidth) / 2 : 0;
          let marginTop = (canvasWrapper.clientHeight > canvasHeight) ? (canvasWrapper.clientHeight - canvasHeight) / 2 : 0;
          canvas.style.marginLeft = marginLeft + "px";
          canvas.style.marginTop = marginTop + "px";
    
          // Dibujar imagen
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    
          rendering = false;
          updateCounter();
          if (callback) callback();
        };
        currentImage.onerror = () => {
          rendering = false;
          alert("Error al cargar la imagen de la p√°gina.");
        };
      } catch (error) {
        rendering = false;
        alert("Error al renderizar la p√°gina: " + error.message);
      }
      pageNum = num;
      updateCounter();
    }
    
    // updateCounter: Actualiza el contador y el slider
    function updateCounter() {
      if (!pdfDoc) {
        document.getElementById("pageCounter").textContent = "## / ##";
        document.getElementById("pageSlider").value = 0;
        document.getElementById("canvasSize").textContent = "[Resoluci√≥n: - x -]";
        document.getElementById("zoomPercentage").textContent = "[Zoom: -%]";
        return;
      }
      const totalPages = pdfDoc.numPages;
      const formattedPageNum = pageNum < 10 ? '0' + pageNum : pageNum;
      const formattedTotalPages = totalPages < 10 ? '0' + totalPages : totalPages;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + formattedTotalPages;
      document.getElementById("pageSlider").value = pageNum;
    }
    
    // Botones de navegaci√≥n
    document.getElementById('prevPage').addEventListener('click', () => {
      if (pageNum > 1) renderPage(pageNum - 1);
    });
    document.getElementById('nextPage').addEventListener('click', () => {
      if (pdfDoc && pageNum < pdfDoc.numPages) renderPage(pageNum + 1);
    });
    document.getElementById('pageSlider').addEventListener('input', (event) => {
      if (!pdfLoaded) return;
      const newPage = parseInt(event.target.value, 10);
      const formattedPageNum = newPage < 10 ? '0' + newPage : newPage;
      document.getElementById("pageCounter").textContent = formattedPageNum + " / " + pdfDoc.numPages;
      if (sliderTimeout) clearTimeout(sliderTimeout);
      sliderTimeout = setTimeout(() => {
        if (newPage !== pageNum) renderPage(newPage);
      }, 150);
    });

    // Botones de rotaci√≥n
    document.getElementById('rotateLeft').addEventListener('click', () => {
      currentRotation = (currentRotation - 90 + 360) % 360;
      delete pageImages[pageNum]; // Invalidar imagen para rotaci√≥n
      renderPage(pageNum);
    });
    document.getElementById('rotateRight').addEventListener('click', () => {
      currentRotation = (currentRotation + 90) % 360;
      delete pageImages[pageNum]; // Invalidar imagen para rotaci√≥n
      renderPage(pageNum);
    });

    // Bot√≥n de reset de zoom
    document.getElementById('resetZoom').addEventListener('click', () => {
      zoomFactor = 1.0;
      renderPage(pageNum);
    });

    // Bot√≥n de zoom out
    document.getElementById('zoomOut').addEventListener('click', () => {
      const oldZoomFactor = zoomFactor;
      zoomFactor = Math.max(0.2, zoomFactor - 0.1);
      const zoomRatio = zoomFactor / oldZoomFactor;
      const centerX = canvasWrapper.scrollLeft + canvasWrapper.clientWidth / 2;
      const centerY = canvasWrapper.scrollTop + canvasWrapper.clientHeight / 2;
      renderPage(pageNum, () => {
        canvasWrapper.scrollLeft = centerX * zoomRatio - canvasWrapper.clientWidth / 2;
        canvasWrapper.scrollTop = centerY * zoomRatio - canvasWrapper.clientHeight / 2;
      });
    });

    // Bot√≥n de zoom in
    document.getElementById('zoomIn').addEventListener('click', () => {
      const oldZoomFactor = zoomFactor;
      zoomFactor = Math.min(5, zoomFactor + 0.1);
      const zoomRatio = zoomFactor / oldZoomFactor;
      const centerX = canvasWrapper.scrollLeft + canvasWrapper.clientWidth / 2;
      const centerY = canvasWrapper.scrollTop + canvasWrapper.clientHeight / 2;
      renderPage(pageNum, () => {
        canvasWrapper.scrollLeft = centerX * zoomRatio - canvasWrapper.clientWidth / 2;
        canvasWrapper.scrollTop = centerY * zoomRatio - canvasWrapper.clientHeight / 2;
      });
    });

    // Bot√≥n de pantalla completa
    document.getElementById('toggleFullscreen').addEventListener('click', toggleFullscreen);
    
    // getDistance: Calcula la distancia entre dos toques
    function getDistance(touch1, touch2) {
      const dx = touch1.pageX - touch2.pageX;
      const dy = touch1.pageY - touch2.pageY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Zoom por pellizco
    canvasWrapper.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
         e.preventDefault();
         isPinching = true;
         pinchZoom.initialDistance = getDistance(e.touches[0], e.touches[1]);
         pinchZoom.initialZoomFactor = zoomFactor;
         pinchZoom.initialScrollLeft = canvasWrapper.scrollLeft;
         pinchZoom.initialScrollTop = canvasWrapper.scrollTop;
         const rect = canvas.getBoundingClientRect();
         pinchZoom.pinchCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2) - rect.left;
         pinchZoom.pinchCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2) - rect.top;
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchmove', function(e) {
      if (e.touches.length === 2) {
         e.preventDefault();
         const currentDistance = getDistance(e.touches[0], e.touches[1]);
         let tempZoom = pinchZoom.initialZoomFactor * (currentDistance / pinchZoom.initialDistance);
         tempZoom = Math.max(0.2, Math.min(tempZoom, 5));
         lastTempZoom = tempZoom;
         const context = canvas.getContext('2d');
         context.clearRect(0, 0, canvas.width, canvas.height);
         const scaleFactor = tempZoom / pinchZoom.initialZoomFactor;
         const newWidth = canvas.width * scaleFactor;
         const newHeight = canvas.height * scaleFactor;
         context.drawImage(currentImage, 0, 0, newWidth, newHeight);
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchend', function(e) {
      if (isPinching && e.touches.length < 2) {
         if (lastTempZoom) {
            zoomFactor = lastTempZoom;
         }
         const zoomRatio = zoomFactor / pinchZoom.initialZoomFactor;
         const centerX = pinchZoom.initialScrollLeft + pinchZoom.pinchCenterX;
         const centerY = pinchZoom.initialScrollTop + pinchZoom.pinchCenterY;
         renderPage(pageNum, function() {
           canvasWrapper.scrollLeft = centerX * zoomRatio - canvasWrapper.clientWidth / 2;
           canvasWrapper.scrollTop = centerY * zoomRatio - canvasWrapper.clientHeight / 2;
         });
         isPinching = false;
      }
    }, { passive: false });
    
    canvasWrapper.addEventListener('touchcancel', function(e) {
      if (isPinching && e.touches.length < 2) {
         isPinching = false;
      }
    }, { passive: false });
  </script>
</body>
</html>
